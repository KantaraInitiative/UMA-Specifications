<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='http://xml2rfc.tools.ietf.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc PUBLIC "-//IETF//DTD RFC 2629//EN"
"http://xml2rfc.tools.ietf.org/authoring/rfc2629.dtd">
<rfc category="std" docName="uma-core" id="kantara" ipr="kantara"
     target="draft" version="2.0">
  <?xml-stylesheet texttype='text/xsl' href='rfc2629.xslt' ?>

  <?rfc toc='yes' ?>

  <?rfc tocdepth='4' ?>

  <?rfc symrefs='yes' ?>

  <?rfc sortrefs='yes' ?>

  <?rfc compact='yes' ?>

  <?rfc subcompact='no' ?>

  <front>
    <title abbrev="UMA Core">User-Managed Access (UMA) 2.0</title>

    <author fullname="Eve Maler" initials="E." role="editor" surname="Maler">
      <organization>ForgeRock</organization>

      <address>
        <email>eve.maler@forgerock.com</email>
      </address>
    </author>

    <author fullname="Maciej Machulak" initials="M." surname="Machulak">
      <organization>iWelcome</organization>

      <address>
        <email>maciej.machulak@iwelcome.com</email>
      </address>
    </author>

    <author fullname="Justin Richer" initials="J." surname="Richer">
      <organization>Bespoke Engineering</organization>

      <address>
        <email>justin@bspk.io</email>
      </address>
    </author>

    <date day="9" month="November" year="2016" />

    <abstract>
      <t>User-Managed Access (UMA) 2.0 is a federated authorization framework
      that defines an extension OAuth 2.0 grant type and uses OAuth and
      federated identity technologies in various other ways. It defines how
      resource owners can control protected-resource access by clients used by
      arbitrary requesting parties, where the resources reside on any number
      of resource servers, and where a centralized authorization server
      governs access based on resource owner policies.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="introduction" title="Introduction">
      <t>User-Managed Access (UMA) 2.0 is a federated authorization framework
      that defines an extension OAuth 2.0 <xref target="RFC6749" /> grant type
      and uses OAuth and federated identity technologies in various other
      ways. It defines how resource owners can control protected-resource
      access by clients used by arbitrary requesting parties, where the
      resources reside on any number of resource servers, and where a
      centralized authorization server governs access based on resource owner
      policies.</t>

      <t>UMA serves numerous use cases where a resource owner uses a dedicated
      service to manage authorization for access to their resources,
      potentially even without the run-time presence of the resource owner. A
      typical example is the following: a web user (an end-user resource
      owner) can authorize a web or native app (a client) to gain one-time or
      ongoing access to a protected resource containing his home address
      stored at a "personal data store" service (a resource server), by
      telling the resource server to respect access entitlements issued by his
      chosen cloud-based authorization service (an authorization server). The
      requesting party operating the client might be the resource owner, where
      the app is run by an e-commerce company that needs to know where to ship
      a purchased item, or the requesting party might be resource owner's
      friend who is using an online address book service to collect contact
      information, or the requesting party might be a survey company that uses
      an autonomous web service to compile population demographics. A variety
      of use cases can be found in <xref target="UMA-usecases" /> and <xref
      target="UMA-casestudies" />.</t>

      <t>Practical control of access among loosely coupled parties requires
      more than just messaging protocols. This specification defines only the
      "technical contract" between UMA-conforming entities. Work is ongoing to
      define recommendations for developing agreements about the rights and
      responsibilities of parties operating and using these entities on a
      contractual or legal level (see, for example, <xref
      target="UMA-obligations" />). Parties operating entities that claim to
      be UMA-conforming should provide documentation of any rights and
      obligations between and among them; see <xref
      target="trust-considerations" /> for more information.</t>

      <t>In enterprise settings, application access management sometimes
      involves letting back-office applications serve only as policy
      enforcement points (PEPs), depending entirely on access decisions coming
      from a central policy decision point (PDP) to govern the access they
      give to requesters. This separation eases auditing and allows policy
      administration to scale in several dimensions. UMA makes use of a
      separation similar to this, letting the resource owner serve as a policy
      administrator crafting authorization strategies for resources under
      their control.</t>

      <t>In order to increase interoperable communication among the
      authorization server, resource server, and client, UMA leverages two
      purpose-built APIs related to the outsourcing of authorization,
      themselves protected by OAuth (or an OAuth-based authentication
      protocol) in embedded fashion.</t>

      <t>The UMA protocol has three broad phases, as shown in <xref
      target="UMA-phases" />.</t>

      <figure align="center" anchor="UMA-phases">
        <preamble>The Three Phases of the UMA Profile of OAuth</preamble>

        <artwork><![CDATA[                                           +--------------+
                                           |   resource   |
          +---------manage (A)------------ |     owner    |
          |                                +--------------+
          |         Phase 1:                      |
          |         protect a                control (C)
          |         resource                      |
          v                                       v
   +------------+               +----------+--------------+
   |            |               |protection|              |
   |  resource  |               |   API    | authorization|
   |   server   |<-protect (B)--|  (needs  |    server    |
   |            |               |   PAT)   |              |
   +------------+               +----------+--------------+
   | protected  |                          | authorization|
   | resource   |                          |     API      |
   |(needs RPT) |                          |  (needs AAT) |
   +------------+                          +--------------+
          ^                                       |
          |         Phases 2 and 3:         authorize (D)
          |         get authorization,            |
          |         access a resource             v
          |                                +--------------+
          +---------access (E)-------------|    client    |
                                           +--------------+

                                           requesting party
]]></artwork>
      </figure>

      <t>The phases work as follows: <list style="hanging">
          <t hangText="Protect a resource">(Described in <xref
          target="protecting-a-resource" />.) The resource owner, who manages
          digital resources at the resource server ("A"), introduces it to the
          authorization server so that the latter can begin protecting the
          resources. To accomplish this, the authorization server presents a
          protection API ("B") to the resource server. This API is protected
          by OAuth (or an OAuth-based authentication protocol) and requires a
          protection API access token (PAT) for access. Out of band, the
          resource owner configures the authorization server with policies
          associated with the resources ("C") that the resource server
          registers for protection.</t>

          <t hangText="Get authorization">(Described in <xref
          target="getting-authz-accessing-resource" />.) The client approaches
          the resource server seeking access to an UMA-protected resource. In
          order to access it successfully, the client must first use the UMA
          grant (&ldquo;D&rdquo;) to obtain a requesting party token (RPT) on
          behalf of the requesting party; as part of this process, the
          requesting party may need to undergo a process of interactive trust
          elevation, for example, supplying identity claims.</t>

          <t hangText="Access a resource">(Described in <xref
          target="getting-authz-accessing-resource" />.) The client
          successfully presents to the resource server an RPT that has
          sufficient authorization data associated with it, gaining access to
          the desired resource ("E"). Phase 3 is effectively the "success
          path" embedded within phase 2.</t>
        </list></t>

      <t>Implementers have the opportunity to develop profiles (see <xref
      target="profiles" />) that specify and restrict various UMA protocol,
      RPT, and identity claim format options, according to deployment and
      usage conditions.</t>

      <section title="Notational Conventions">
        <t>The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT',
        'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'MAY', and 'OPTIONAL' in this
        document are to be interpreted as described in <xref
        target="RFC2119" />.</t>

        <t>Unless otherwise noted, all protocol properties and values are case
        sensitive. JSON <xref target="RFC7159" /> data structures defined by
        this specification MAY contain extension properties that are not
        defined in this specification. Any entity receiving or retrieving a
        JSON data structure SHOULD ignore extension properties it is unable to
        understand. Extension names that are unprotected from collisions are
        outside the scope of this specification.</t>
      </section>

      <section anchor="terminology" title="Terminology">
        <t>UMA introduces the following new terms and enhancements of OAuth
        term definitions.<list hangIndent="6" style="hanging">
            <t hangText="User-Managed Access grant (UMA grant)"><vspace />An
            extension OAuth grant type defined by this specification as part
            of the overall authorization interface presented by the
            authorization server.</t>

            <t hangText="resource owner"><vspace />An entity capable of
            granting access to a protected resource, the "user" in
            User-Managed Access. This is typically an end-user (a natural
            person) but it can also be a corporation or other legal
            person.</t>

            <t hangText="policy">The configuration parameters of an
            authorization server that effect resource access management.
            Authorization policies typically include elements similar to parts
            of speech; for example, "subjects" describe those seeking access
            (requesting parties and clients), "verbs" describe operational
            scopes of access, and "objects" describe targeted resources to
            protect. Policy configuration takes place between the resource
            owner and the authorization server, and thus is out of scope for
            this specification.</t>

            <t hangText="requesting party"><vspace />An end-user, or a
            corporation or other legal person, that uses a client to seek
            access to a protected resource. The requesting party may or may
            not be the same party as the resource owner.</t>

            <t hangText="client"><vspace />An application making protected
            resource requests with the resource owner's authorization and on
            the requesting party's behalf.</t>

            <t hangText="claim"><vspace />A statement of the value or values
            of one or more attributes of an entity. An authorization server
            may need to collect and assess one or more claims of a requesting
            party or client against the policy conditions of a resource owner
            as part of protecting a resource.</t>

            <t hangText="protected resource">A digital resource to which a
            resource owner is able to control access grants. From the resource
            server's perspective, the resource might consist of one or
            multiple parts, but it is managed as a single resource from the
            perspective of UMA protection. In authorization policy
            terminology, a resource is the "object" being protected. This term
            derives from <xref target="OAuth-resource-reg" />.</t>

            <t hangText="scope">A bounded extent of access that is possible to
            perform on a protected resource. In authorization policy
            terminology, a scope is one of the potentially many "verbs" that
            can logically apply to a resource ("object"). UMA associates
            scopes with labeled resources. This term derives from <xref
            target="OAuth-resource-reg" />.</t>

            <t hangText="token">A packaged collection of data meant to be
            transmitted to another entity. A token could be used for
            authorized access (an "access token"), or could be used to
            exchange information about a subject (a "claim token").</t>

            <t hangText="requesting party token (RPT)">An UMA access token
            associated with a set of permissions, used by the client to gain
            access to protected resources at the resource server.</t>

            <t hangText="authorization server"><vspace />A server that issues
            permissions and RPTs to a client and protects resources managed at
            a resource server.</t>

            <t hangText="authorization process"><vspace />The process through
            which the client attempts to obtain an RPT from the authorization
            server in order to access a protected resource on behalf of a
            requesting party. The process involves two activities: claims
            collection and authorization assessment. Claims collection
            involves either claims pushed by the client or claims
            interactively gathered from the requesting party, or both.
            Authorization assessment involves assessing any claims and other
            information in evidence against the resource owner's policy
            conditions in order to mitigate access authorization risk. The two
            activities alternate and the pair can repeat; either can come
            first. The process concludes when the client definitively succeeds
            or fails in obtaining an RPT.</t>

            <t hangText="permission">Authorized access to a particular
            resource with one or more scopes. A resource server requests one
            or more permissions on behalf of a client at an authorization
            server, receiving a permission ticket representing the entire
            requested set in return, and if an RPT is ultimately issued, it is
            associated with some number of granted permissions. In
            authorization policy terminology, a permission is an entitlement
            that includes a "subject" (requesting party), "verbs" (one or more
            scopes of access), and an "object" (resource).</t>

            <t hangText="permission ticket">A correlation handle that is
            conveyed from an authorization server to a resource server, from a
            resource server to a client, and ultimately from a client back to
            an authorization server, to enable the authorization server to
            assess the correct policies to apply to a request for
            permissions.</t>

            <t hangText="RPT endpoint">An endpoint at the authorization server
            that issues RPTs and permissions to the client.</t>

            <t hangText="protection API access token (PAT)">An OAuth access
            token with the scope <spanx style="verb">uma_protection</spanx>,
            used by the resource server at the protection API, consisting of
            the resource registration, permission registration, and token
            introspection endpoints.</t>

            <t hangText="persisted claims token (PCT)">A correlation handle
            issued by an authorization server that represents a set of claims
            collected during one authorization process to be used during
            future authorization processes. An end-user requesting party MAY
            have provided authorization in some interactive fashion for the
            authorization server to persist this information across
            authorization processes.</t>

            <t hangText="resource registration endpoint">An endpoint at the
            authorization server that allows the resource server to register
            resources for protection.</t>

            <t hangText="permission endpoint">An endpoint at the authorization
            server that allows the resource server to request permissions for
            access to resources on behalf of the client.</t>

            <t hangText="token introspection endpoint">An endpoint at the
            authorization server that allows the resource server to query the
            status of an RPT and its associated permissions.</t>
          </list></t>
      </section>

      <section anchor="endpoint-discussion"
               title="Achieving Distributed Access Control">
        <t>The software components that fill the roles of UMA authorization
        servers, resource servers, and clients respectively are intended to
        work in an interoperable fashion when each is operated by an
        independent party (for example, different organizations). For this
        reason, UMA specifies communications channels that the authorization
        server MUST implement as HTTP-based APIs that MUST use TLS and OAuth
        (or OAuth-based authentication protocol) protection, and that the
        resource server MUST implement as an HTTP-based interface. UMA's use
        of TLS is governed by <xref target="BCP195" />, which discusses
        deployment and adoption characteristics of different TLS versions.</t>

        <t>For those OAuth protection use cases where an identity token is
        desired in addition to an access token, it is RECOMMENDED that an
        OAuth-based authentication protocol such as OpenID Connect <xref
        target="OIDCCore" /> be used.</t>

        <t>It is also REQUIRED, in turn, for resource servers and clients on
        the requesting side of UMA interactions to use these channels, unless
        a profile is being used that enables API extensibility. The profiles
        that enable such alternatives are provided in <xref
        target="comms-profiles" />.</t>

        <section anchor="protection-api"
                 title="Protection API and Protection API Access Token">
          <t>The authorization server MUST present an HTTP-based protection
          API, protected by TLS and OAuth (or an OAuth-based authentication
          protocol), for use by resource servers. The authorization server
          thus has an OAuth token endpoint and authorization endpoint. The
          authorization server MUST declare all of its protection API
          endpoints in its configuration (see <xref
          target="am-endpoints" />).</t>

          <t>The protection API consists of three endpoints:<list
              style="symbols">
              <t>Resource registration endpoint as defined by <xref
              target="OAuth-resource-reg" /></t>

              <t>Permission endpoint as defined by <xref
              target="register-permission" /></t>

              <t>Token introspection endpoint as defined by <xref
              target="RFC7662" /> and <xref
              target="token-introspection" /></t>
            </list></t>

          <t>The UMA resource server, which is the entity seeking protection
          API access, MUST be an OAuth client with client credentials and the
          ability to get an OAuth access token with at least the scope <spanx
          style="verb">uma_protection</spanx>. An access token with at least
          this scope is called a protection API access token (PAT). If a
          request to an endpoint fails due to an invalid, missing, or expired
          PAT, or requires higher privileges at this endpoint than provided by
          the PAT, the authorization server responds with an OAuth error.</t>

          <t>A PAT binds a resource owner, a resource server the owner uses
          for resource management, and an authorization server the owner uses
          for protection of resources at this resource server. It is not
          specific to any client or requesting party. The issuance of a PAT
          represents the approval of the resource owner for this resource
          server to use this authorization server for protecting some or all
          of the resources belonging to this resource owner. Any OAuth
          authorization grant type might be appropriate depending on
          circumstances; for example, the client credentials grant is useful
          in the case of an organization acting as a resource owner, whereas
          an interactive grant type is typically more appropriate for
          capturing the approval of an end-user resource owner.</t>

          <t>Note: The PAT is used in requesting permission on the client's
          behalf (as described in <xref target="register-permission" />). One
          circumstance precipitating this action is when the client has
          attempted access without an RPT (as described in <xref
          target="without-rpt" />). In order for the resource server to know
          which authorization server to approach and which PAT (representing a
          resource owner) and resource identifier to supply, the resource
          server's API needs be structured in such a way that it can derive
          this information from the client's RPT-free access attempt. In
          practice, this information likely needs to be passed through the
          URI, headers, or body of the client's request.</t>
        </section>

        <section anchor="authorization-api"
                 title="UMA Grant Type and Requesting Party Token">
          <t>The authorization server issues access tokens that enable client
          access to UMA-protected resources on the requesting party&rsquo;s
          behalf using an OAuth extension grant type called the UMA grant
          type. In this grant type, the client uses the OAuth token endpoint
          on the requesting party&rsquo;s behalf. To differentiate access
          tokens issued through the UMA grant type from other tokens involved
          in the UMA process, this access token is called the requesting party
          token (RPT).</t>

          <t>In addition to the OAuth token endpoint being used for RPT
          issuance, the authorization server MAY also provide a claims
          interaction endpoint for various types of direct interaction with an
          end-user requesting party, which is somewhat analogous to the
          redirection URI defined in <xref target="RFC6749" /> for use by the
          resource owner; see <xref target="claim-redirect" /> for more
          information about this option.</t>

          <t>The authorization server MAY choose to issue a persisted claims
          token (PCT) to the client at the conclusion of the authorization
          process in order to optimize future RPT requests. The PCT represents
          the set of claims collected by the authorization server during the
          authorization process. It is intended to be used when this client
          obtains a new RPT for this requesting party at this authorization
          server, for the same or a different resource at the same or a
          different resource server, available under the same or different
          policies, controlled by the same or a different resource owner.</t>

          <t>An UMA client seeking access to a resource needs OAuth client
          credentials issued by the UMA authorization server protecting that
          resource.</t>

          <t>The resource server MAY present to clients whatever HTTP-based
          APIs or endpoints it wishes. To protect any of its resources
          available in this fashion using UMA, it MUST require a client to
          present a valid RPT with sufficient permissions for access.</t>

          <t>Note: The first step in the process of gaining access
          authorization is for a client to attempt access to the resource
          server's API without an RPT (as described in <xref
          target="without-rpt" />), and the second is for the resource server
          to request permissions at the authorization server on the client's
          behalf, which requires a PAT for authorization. In order for the
          resource server to know which authorization server to approach and
          which PAT (representing a resource owner) and resource identifier to
          supply, the resource server's API needs be structured in such a way
          that it can derive this information from the client's RPT-free
          access attempt. In practice, this information likely needs to be
          passed through the URI, headers, or body of the client's
          request.</t>
        </section>

        <section title="Time-to-Live Considerations">
          <t>The authorization server has the opportunity to manage the
          validity periods of access tokens that it issues, their
          corresponding refresh tokens where applicable, the individual
          permission components associated with RPTs where applicable, caching
          periods for responses, and even the client credentials that it
          issues. Different time-to-live strategies may be suitable for
          different resources and scopes of access, and the authorization
          server has the opportunity to give the resource owner control over
          lifetimes of tokens and permissions issued on their behalf through
          policy. These options are all outside the scope of this
          specification.</t>
        </section>
      </section>

      <section anchor="am-endpoints"
               title="Authorization Server Configuration">
        <t>The authorization server supplies configuration information in
        order to document its endpoints and the major conformance options it
        supports.</t>

        <t>Where this specification does not already require optional features
        to be documented, it is RECOMMENDED that authorization server
        deployers document any profiled or extended features explicitly and
        use extension configuration properties to indicate their usage.</t>

        <section anchor="config-properties" title="Configuration Properties">
          <t>The authorization server has configuration properties as follows.
          <list hangIndent="6" style="hanging">
              <t hangText="issuer"><vspace />REQUIRED. A URI with no query or
              fragment component that the authorization server asserts as its
              issuer identifier. This value MUST be identical to the web
              location of the configuration document minus the <spanx
              style="verb">.well-known/uma2-configuration</spanx> path
              components.</t>

              <t hangText="claim_token_profiles_supported"><vspace />OPTIONAL.
              Claim token format profiles supported by this authorization
              server. The property value is an array of string values, where
              each string value MAY be a URI.</t>

              <t hangText="uma_profiles_supported"><vspace />OPTIONAL. UMA
              profiles supported by this authorization server. The property
              value is an array of string values, where each string value is a
              URI identifying an UMA profile. Examples of UMA profiles are the
              API extensibility profiles defined in <xref
              target="comms-profiles" />.</t>

              <t hangText="registration_endpoint"><vspace />OPTIONAL. The
              endpoint to use for performing dynamic client registration in
              the case of the use of <xref target="RFC7591" /> or<xref
              target="OIDCDynClientReg" />. The presence of this property
              indicates authorization server support for dynamic client
              registration feature; its absence indicates a lack of support.
              If the authorization server supports dynamic client
              registration, it MUST allow client applications to register a
              <spanx style="verb">claims_redirect_uri</spanx> metadata field,
              as defined in <xref target="claim-redirect" />.</t>

              <t hangText="token_endpoint"><vspace />REQUIRED. The endpoint
              URI at which the resource server is the authorization server for
              a PAT on behalf of the resource owner (by requesting the OAuth
              scope <spanx style="verb">uma_protection</spanx>) and at which
              the client asks the authorization server for an RPT on behalf of
              the requesting party using the UMA grant.</t>

              <t hangText="authorization_endpoint"><vspace />REQUIRED. The
              endpoint URI at which the resource server gathers the
              authorization of an end-user resource owner for PAT issuance.
              Note that the UMA grant does not involve the client gathering
              the authorization of an end-user requesting party directly.</t>

              <t hangText="claims_interaction_endpoint"><vspace />OPTIONAL. A
              static endpoint URI at which the authorization server declares
              that it interacts with end-user requesting parties to gather
              claims. If the authorization server also provides a claims
              interaction endpoint URI as part of its <spanx
              style="verb">redirect_user</spanx> hint in a <spanx
              style="verb">need_info</spanx> response to a client on
              authorization failure (see <xref
              target="authorization-failure" />), that value overrides the one
              provided in this configuration property. Providing the static
              endpoint URI is useful for enabling interactive claims gathering
              prior to pushed-claims flows, so that, for example, it is
              possible to gather requesting party authorization for persisting
              all claims subsequently collected.</t>

              <t hangText="introspection_endpoint"><vspace />REQUIRED. The
              endpoint URI at which the resource server introspects an RPT
              presented to it by a client. Usage of this endpoint is defined
              by <xref target="RFC7662" /> and <xref
              target="token-introspection" />. A valid PAT MUST accompany
              requests to this protected endpoint.</t>

              <t hangText="resource_registration_endpoint"><vspace />REQUIRED.
              The endpoint URI at which the resource server registers
              resources to put them under authorization manager protection.
              Usage of this endpoint is defined by <xref
              target="OAuth-resource-reg" /> and <xref
              target="protecting-a-resource" />. A valid PAT MUST accompany
              requests to this protected endpoint.</t>

              <t hangText="permission_endpoint"><vspace />REQUIRED. The
              endpoint URI at which the resource server requests permissions
              on the client's behalf. Usage of this endpoint is defined by
              <xref target="register-permission" />. A valid PAT MUST
              accompany requests to this protected endpoint.</t>
            </list></t>
        </section>

        <section title="Configuration Document">
          <t>The authorization server MUST make its configuration properties
          available in a JSON document at the path formed by concatenating the
          string <spanx style="verb">/.well-known/uma2-configuration</spanx>
          to the <spanx style="verb">issuer</spanx> configuration property
          value as defined in <xref target="config-properties" />. The syntax
          and semantics of <spanx style="verb">/.well-known</spanx> are
          defined in <xref target="RFC5785" /> and apply to the <spanx
          style="verb">issuer</spanx> value when it contains no path
          component.</t>
        </section>

        <section title="Requests to Authorization Server for Configuration Document">
          <t>Any entity, such as a resource server or client, seeking an
          authorization server configuration document MUST query it using an
          HTTP GET request.</t>

          <figure>
            <preamble>Example:</preamble>

            <artwork><![CDATA[GET /.well-known/uma2-configuration HTTP/1.1
Host: example.com
}
]]></artwork>
          </figure>

          <t>If the <spanx style="verb">issuer</spanx> value contains a path
          component, the caller MUST remove any terminating slash before
          appending <spanx
          style="verb">/.well-known/uma2-configuration</spanx>.</t>

          <figure>
            <preamble>For example, the caller would make the following request
            to the issuer <spanx
            style="verb">https://example.com/issuer1</spanx>, since the <spanx
            style="verb">issuer</spanx> value contains a path
            component:</preamble>

            <artwork><![CDATA[GET /issuer1/.well-known/uma2-configuration HTTP/1.1
Host: example.com
}
]]></artwork>
          </figure>
        </section>

        <section title="Authorization Server Response Containing Configuration Document">
          <t>A successful authorization server response to a configuration
          document query MUST use the HTTP 200 (OK) status code and return a
          JSON object using the <spanx style="verb">application/json</spanx>
          content type containing the configuration properties as defined in
          <xref target="config-properties" />.</t>

          <figure>
            <preamble>Example (note the use of <spanx
            style="verb">https:</spanx> for endpoints throughout):</preamble>

            <artwork><![CDATA[HTTP/1.1 200 OK
Content-Type: application/json
...

{  
   "issuer":"https://example.com",
   "claim_token_profiles_supported":[  
      "https://example.com/claims/formats/token1"
   ],
   "registration_endpoint":"https://as.example.com/dyn_client_reg_uri",
   "token_endpoint":"https://as.example.com/token_uri",
   "authorization_endpoint":"https://as.example.com/authz_uri",
   "claims_interaction_endpoint":"https://as.example.com/claims_uri",
   "resource_registration_endpoint":"https://as.example.com/rs/rsrc_uri",
   "introspection_endpoint":"https://as.example.com/rs/status_uri",
   "permission_endpoint":"https://as.example.com/rs/perm_uri"
}
]]></artwork>
          </figure>
        </section>
      </section>
    </section>

    <section anchor="protecting-a-resource" title="Protecting a Resource">
      <t>The resource owner, resource server, and authorization server perform
      the following actions to put resources under protection. This list
      assumes that the resource server has discovered the authorization
      server's configuration document and endpoints as needed.<list
          style="numbers">
          <t>The authorization server issues client credentials to the
          resource server. It is OPTIONAL for the client credentials to be
          provided dynamically through <xref target="RFC7591" /> or <xref
          target="OIDCDynClientReg" />; alternatively, they MAY use a static
          process.</t>

          <t>The resource server acquires a PAT (as defined in <xref
          target="protection-api" />) from the authorization server. It is
          OPTIONAL for the resource owner to introduce the resource server to
          the authorization server dynamically (for example, through a
          "NASCAR"-style user interface where the resource owner selects a
          chosen authorization server); alternatively, they MAY use a static
          process that may or may not directly involve the resource owner at
          introduction time.</t>

          <t>In an ongoing fashion, the resource server registers any
          resources with the authorization server to put them under
          protection, using the resource registration endpoint of the
          protection API (see <xref target="OAuth-resource-reg" />).</t>
        </list></t>

      <t>Note: The resource server is free to offer the option to protect any
      subset of the resource owner's resources using different authorization
      servers or other means entirely, or to protect some resources and not
      others. Additionally, the choice of protection regimes can be made
      explicitly by the resource owner or implicitly by the resource server.
      Any such partitioning by the resource server or owner is outside the
      scope of this specification.</t>

      <t>Once a resource has been placed under authorization server protection
      through the registration of a resource description document for it, and
      until such a description's deletion by the resource server, the resource
      server MUST limit access to corresponding resources, requiring
      sufficient permissions associated with client-presented RPTs by the
      authorization server (see <xref
      target="permission-success-to-client" />).</t>

      <t>Note: The PAT that the resource server uses to register resources
      must also be used later during client access attempts, for example, in
      requesting permission on a client's behalf (as described in <xref
      target="register-permission" />). One circumstance precipitating this
      action is when the client has attempted access without an RPT (as
      described in <xref target="without-rpt" />). In order for the resource
      server to know which authorization server to approach and which PAT
      (representing a resource owner) and resource identifier to supply, the
      resource server's API needs be structured in such a way that it can
      derive this information from the client's RPT-free access attempt. In
      practice, this information likely needs to be passed through the URI,
      headers, or body of the client's request.</t>
    </section>

    <section anchor="getting-authz-accessing-resource"
             title="Getting Authorization and Accessing a Resource">
      <t>An authorization server orchestrates and controls clients' access on
      their requesting parties' behalf to a resource owner's protected
      resources at a resource server, under conditions specified by that
      resource owner through policy.</t>

      <t>The process of getting authorization and accessing a resource always
      begins with the client attempting access at a protected resource
      endpoint at the resource server. Several aspects of the client's
      behavior are out of scope for this specification:<list style="symbols">
          <t>How the client acquired knowledge of the resource server's
          client-facing interface and the specific endpoint of the desired
          protected resource. For example, the resource server might have a
          formally documented API or it might serve up a simple web page, and
          the resource owner might have advertised the endpoint publicly on a
          blog or other website, listed it in a discovery service, or emailed
          a link to a particular intended requesting party. Note: A client
          first attempts access to a resource without an RPT, and the resource
          server next needs to make a request at the authorization server to
          continue the authorization-seeking process. In order for the
          resource server to know which authorization server to approach and
          which PAT (representing a resource owner) and resource identifier to
          supply on that request, the resource server's API needs be
          structured in such a way that it can derive this information from
          the client's RPT-free access attempt. In practice, this information
          likely needs to be passed through the URI, headers, or body of the
          client's request.</t>

          <t>The impetus for the client's access attempt. For example, its
          end-user requesting party might have clicked on a thumbnail
          representation of a graphics-based resource to retrieve a larger
          version.</t>
        </list></t>

      <t>In brief, the entire process is as follows. <list style="symbols">
          <t>The client attempts to access the protected resource (see <xref
          target="client-attempts-access" />).</t>

          <t>If the client's request at the protected resource has no RPT, or
          has an invalid RPT or insufficient permissions associated with the
          RPT as determined through RPT status checking (see <xref
          target="check-rpt-status" />), the resource server requests
          permissions on the client's behalf with the relevant authorization
          server (see <xref target="register-permission" />), and responds to
          the client with the resulting permission ticket and the
          authorization server's location using a <spanx
          style="verb">WWW-Authenticate: UMA</spanx> header (see <xref
          target="permission-success-to-client" />).</t>

          <t>If the resource server fails to get a permission ticket, it
          responds to the client with a warning header instead (see <xref
          target="permission-failure-to-client" />).</t>

          <t>If the client receives a permission ticket and authorization
          server location from the resource server, it asks for an RPT from
          the authorization server (see <xref
          target="seek-authorization" />).</t>

          <t>If the authorization request and any additional information
          required for trust elevation by the authorization server (see <xref
          target="need-info" />) sufficiently matches resource owner policies,
          the authorization server returns an RPT associated with the
          appropriate permissions to the client (see <xref
          target="give-rpt" />).</t>

          <t>If the client's attempt has a valid RPT with sufficient
          permissions, the resource owner's policies have been met for access
          to the protected resource (see <xref target="give-access" />).</t>
        </list></t>

      <t>The recipient of each request message SHOULD respond unless it
      detects a security concern, such as a suspected denial of service attack
      that can be mitigated by rate limiting.</t>

      <section anchor="client-attempts-access"
               title="Client Attempts Access to Protected Resource">
        <t>This interaction assumes that the resource server has already
        registered any relevant resources prior to the client's access attempt
        at any resource that is intended to be UMA-protected.</t>

        <section anchor="without-rpt"
                 title="Client Request to Resource Server With No RPT">
          <figure>
            <preamble>Example of a client request at a protected resource
            carrying no RPT:</preamble>

            <artwork><![CDATA[GET /users/alice/album/photo.jpg HTTP/1.1
Host: photoz.example.com
...
]]></artwork>
          </figure>

          <t>If the resource server chooses to respond, it next requests one
          or more permissions on the client's behalf (see <xref
          target="register-permission" />).</t>
        </section>

        <section anchor="with-rpt"
                 title="Client Request to Resource Server With RPT">
          <figure>
            <preamble>Example of a client request at a protected resource
            carrying an RPT using the UMA <spanx style="verb">Bearer</spanx>
            RPT profile:</preamble>

            <artwork><![CDATA[GET /users/alice/album/photo.jpg HTTP/1.1
Authorization: Bearer vF9dft4qmT
Host: photoz.example.com
...
]]></artwork>
          </figure>

          <t>If the resource server chooses to respond, it next determines the
          RPT's status (see <xref target="check-rpt-status" />).</t>
        </section>
      </section>

      <section anchor="register-permission"
               title="Resource Server Requests Permissions on Client's Behalf With Authorization Server">
        <t>If the client's request at the protected resource has no RPT, or
        has an invalid RPT or insufficient permissions associated with the RPT
        as determined through RPT status checking (see <xref
        target="check-rpt-status" />), then assuming the resource server
        chooses to respond to the client, it MUST use the protection API's
        permission endpoint to request permissions with the corresponding
        authorization server on the client's behalf. The extent of the set of
        requested permissions MUST suffice for the extent of the client's
        access attempt at that resource.</t>

        <t>Note: The resource server is free to choose the extent of the
        requested permissions, as long as it minimally suffices for the access
        attempted by the client. For example, it can choose to request
        permission for access to a single resource with several scopes, or a
        set of permissions for multiple resources that together are greater in
        extent, than the specific resource and scope that the client attempted
        to access.</t>

        <t>The PAT provided in the API request enables the authorization
        server to map the request to the appropriate resource owner. The
        authorization server returns a permission ticket in its response for
        the resource server to give to the client that represents the same
        extent of requested access that the resource server requested.</t>

        <section title="Resource Server Request to Permission Endpoint">
          <t>The resource server uses the POST method at the permission
          endpoint. The body of the HTTP request message contains a JSON
          object (for a request containing a single resource identifier) or
          array (for a request containing more than one resource identifier)
          providing the request, using a format derived from the resource
          description format specified in <xref
          target="OAuth-resource-reg" />, as follows. The object used in both
          forms has the following properties:<list style="hanging">
              <t hangText="resource_id">REQUIRED. The identifier for a
              resource to which the resource server is requesting permission
              on behalf of the client. The identifier MUST correspond to a
              resource that was previously registered.</t>

              <t hangText="resource_scopes">REQUIRED. An array referencing one
              or more identifiers of scopes to which the resource server is
              requesting access for this resource on behalf of the client.
              Each scope identifier MUST correspond to a scope that was
              previously registered by this resource server for the referenced
              resource.</t>
            </list></t>

          <figure>
            <preamble>Example of an HTTP request for a single-resource-set
            permission at the authorization server's permission endpoint, with
            a PAT in the header:</preamble>

            <artwork><![CDATA[POST /host/rsrc_uri HTTP/1.1
Content-Type: application/json
Host: as.example.com
Authorization: Bearer 204c69636b6c69
...

{  
   "resource_id":"112210f47de98100",
   "resource_scopes":[  
      "view",
      "http://photoz.example.com/dev/actions/print"
   ]
}
]]></artwork>
          </figure>

          <figure>
            <preamble>Example of an HTTP request for a multiple-resource-set
            permission at the authorization server's permission endpoint, with
            a PAT in the header:</preamble>

            <artwork><![CDATA[POST /host/rsrc_uri HTTP/1.1
Content-Type: application/json
Host: as.example.com
Authorization: Bearer 204c69636b6c69
...

[  
   {  
      "resource_id":"7b727369647d",
      "scopes":[  
         "view",
         "crop",
         "lightbox"
      ]
   },
   {  
      "resource_id":"7b72736964327d",
      "scopes":[  
         "view",
         "layout",
         "print"
      ]
   },
   {  
      "resource_id":"7b72736964337d",
      "scopes":[  
         "http://www.example.com/scopes/all"
      ]
   }
]
]]></artwork>
          </figure>
        </section>

        <section anchor="ticket-management"
                 title="Permission Ticket Creation and Management">
          <t>The authorization server uses a permission ticket to maintain the
          state of a set of requested permissions, initially conveyed on the
          client's behalf by the resource server at attempted resource access
          time, for the period of time that the client continues to seek
          authorization for that attempted access.</t>

          <t>The authorization server MUST make permission ticket values
          unguessable by resource servers and clients. Within these
          constraints, however, the authorization server MAY format the ticket
          however it chooses, for example either as a random string that
          references data held on the server or by including data within the
          ticket itself.</t>

          <t>Permission tickets MUST be single-use.</t>

          <t>The authorization server MUST invalidate a permission ticket when
          the client presents the permission ticket either to the token
          endpoint or interactive claims endpoint; or when the permission
          ticket expires, whichever occurs first.</t>

          <t>See <xref target="UMA-Impl" /> for more information about
          permission ticket management.</t>
        </section>

        <section title="Authorization Server Response to Resource Server on Permission Request Success">
          <t>If the authorization server is successful in creating a
          permission ticket in response to the resource server's request, it
          responds with an HTTP 201 (Created) status code and includes the
          <spanx style="verb">ticket</spanx> property in the JSON-formatted
          body.</t>

          <figure>
            <preamble>For example:</preamble>

            <artwork><![CDATA[HTTP/1.1 201 Created
Content-Type: application/json
...

{  
   "ticket":"016f84e8-f9b9-11e0-bd6f-0021cc6004de"
}
]]></artwork>
          </figure>
        </section>

        <section title="Authorization Server Response to Resource Server on Permission Request Failure">
          <t>If the resource server's permission registration request is
          authenticated properly but fails due to other reasons, the
          authorization server responds with an HTTP 400 (Bad Request) status
          code and includes one of the following UMA error codes (see <xref
          target="uma-error-response" /> for more information about error
          codes and responses):<list style="hanging">
              <t hangText="invalid_resource_id">At least one of the provided
              resource identifiers was not found at the authorization
              server.</t>

              <t hangText="invalid_scope">At least one of the scopes included
              in the request was not registered previously by this resource
              server for the referenced resource.</t>
            </list></t>
        </section>
      </section>

      <section title="Resource Server Responds to Client">
        <t>If the resource server chooses to respond to the client's access
        attempt, it has three possible paths.</t>

        <section anchor="permission-success-to-client"
                 title="Resource Server Response to Client on Permission Request Success">
          <t>If the client's request at a protected resource has no RPT, or
          has an invalid RPT or insufficient permissions associated with the
          RPT as determined through RPT status checking (see <xref
          target="check-rpt-status" />), and the resource server successfully
          requested one or more permissions and received a permission ticket
          (see <xref target="register-permission" />), then assuming the
          resource server chooses to respond to the client with an UMA
          response, it MUST provide a <spanx
          style="verb">WWW-Authenticate</spanx> header with the authentication
          scheme <spanx style="verb">UMA</spanx>, with the <spanx
          style="verb">issuer</spanx> URI from the authorization server's
          configuration document in an <spanx style="verb">as_uri</spanx>
          parameter and the just-received permission ticket in a <spanx
          style="verb">ticket</spanx> parameter.</t>

          <figure>
            <preamble>Example of the resource server's response to a client
            after having requested one or more permissions and received a
            permission ticket:</preamble>

            <artwork><![CDATA[HTTP/1.1 401 Unauthorized
WWW-Authenticate: UMA realm="example",
  as_uri="https://as.example.com",
  ticket="016f84e8-f9b9-11e0-bd6f-0021cc6004de"
...
]]></artwork>
          </figure>

          <t>On receiving a response from the resource server with permission
          ticket and authorization server location information, the client
          next seeks authorization (see <xref
          target="seek-authorization" />).</t>
        </section>

        <section anchor="permission-failure-to-client"
                 title="Resource Server Response to Client on Permission Request Failure">
          <t>If the client's request at the protected resource has no RPT, or
          has an invalid RPT or insufficient permissions associated with the
          RPT as determined through RPT status checking (see <xref
          target="check-rpt-status" />), and the resource server received an
          error of any kind from the authorization server when trying to
          request permissions such that it did not receive a permission
          ticket, then assuming the resource server chooses to respond to the
          client, it is unable to create a <spanx
          style="verb">WWW-Authenticate: UMA</spanx> header and MUST include a
          header of the following form in its response to the client: <spanx
          style="verb">Warning: 199 - "UMA Authorization Server
          Unreachable"</spanx>.</t>

          <figure>
            <preamble>For example:</preamble>

            <artwork><![CDATA[HTTP/1.1 403 Forbidden
Warning: 199 - "UMA Authorization Server Unreachable"
...
]]></artwork>
          </figure>
        </section>

        <section anchor="give-access"
                 title="Resource Server Response to Client on Sufficiency of Authorization">
          <t>The client's presentation of a valid RPT associated with
          sufficient permissions as determined through RPT status checking
          (see <xref target="check-rpt-status" />) indicates that the resource
          owner's policies have been met for access to the protected resource.
          The resource server MAY apply additional authorization controls when
          determining how to respond.</t>

          <figure>
            <preamble>Example of the resource server's response to the
            client:</preamble>

            <artwork><![CDATA[HTTP/1.1 200 OK
Content-Type: application/json
...

{  
   "f_number":"f/5.6",
   "exposure":"1/320",
   "focal_length_mm":150,
   "iso":400,
   "flash":false
}
]]></artwork>
          </figure>

          <t>The resource server MUST NOT give access in the case of an
          invalid RPT or an RPT associated with insufficient authorization. To
          ensure the integrity of the ecosystem in which the resource server,
          authorization server, and resource owner are participating, it is
          RECOMMENDED for the parties to establish agreements about access
          rules in this case on a legal or contractual level. See <xref
          target="trust-considerations" /> for more information.</t>
        </section>
      </section>

      <section anchor="check-rpt-status"
               title="Resource Server Determines RPT Status">
        <t>If a client's request for a protected resource has an RPT (an
        example of which appears in <xref target="with-rpt" />), and the
        resource server chooses to respond to the client, then it MUST
        determine the RPT's status, including whether it is active and, if so,
        its associated permissions indicating whether the client is authorized
        for access before taking next actions.</t>

        <t>Depending on the nature of the RPT as issued by the authorization
        server and on operative caching parameters, the resource server MAY
        take any of the following actions as appropriate to determine the
        RPT's status:<list style="symbols">
            <t>Validate the RPT locally if it is self-contained</t>

            <t>Introspect the RPT at the authorization server using the OAuth
            token introspection endpoint (defined by <xref
            target="RFC7662" />) that is part of the protection API</t>

            <t>Use a cached copy of the token introspection response if
            allowed</t>
          </list></t>

        <t>In the case of token introspection, the authorization server's
        response contains an extended version of the OAuth introspection
        object. A number of security considerations around handling and
        interpreting the RPT can be found throughout <xref
        target="getting-authz-accessing-resource" />, and in <xref
        target="sec-consid" />.</t>

        <t>The following sections describe the process when the resource
        server introspects the RPT at the authorization server and the form of
        the introspection object.</t>

        <section anchor="token-introspection"
                 title="Resource Server Request to Token Introspection Endpoint">
          <t>The resource server's request for introspection of an RPT MUST
          use the OAuth token introspection endpoint (defined by <xref
          target="RFC7662" />) declared by the authorization server in its
          configuration document. The authorization server MUST require
          requests to this endpoint to be accompanied by a PAT. The PAT
          provides resource-owner context to the authorization server as well
          as demonstrating authorized access.</t>

          <figure>
            <preamble>Example of the resource server's request to the
            authorization server for introspection of an RPT, with a PAT in
            the header:</preamble>

            <artwork><![CDATA[POST /rs/status_uri HTTP/1.1
Host: as.example.com
Authorization: Bearer 204c69636b6c69
...
token=sbjsbhs(/SSJHBSUSSJHVhjsgvhsgvshgsv
}
]]></artwork>
          </figure>
        </section>

        <section anchor="uma-bearer-token-profile"
                 title="Authorization Server Response to Resource Server on Token Introspection Success">
          <t>The authorization server's response to the resource server MUST
          use <xref target="RFC7662" />, responding with a JSON object with
          the structure dictated by that specification, extended as
          follows.</t>

          <t>If the <spanx style="verb">active</spanx> property has a Boolean
          value of <spanx style="verb">true</spanx>, then the JSON object MUST
          NOT contain a <spanx style="verb">scope</spanx> claim, and MUST
          contain an extension property with the name <spanx
          style="verb">permissions</spanx> that contains an array of zero or
          more values, each of which is an object consisting of these
          properties:<list style="hanging">
              <t hangText="resource_id">REQUIRED. A string that uniquely
              identifies the protected resource, access to which has been
              granted to this client on behalf of this requesting party. The
              identifier MUST correspond to a resource that was previously
              registered as protected.</t>

              <t hangText="resource_scopes">REQUIRED. An array referencing one
              or more strings representing scopes to which access was granted
              for this resource. Each string MUST correspond to a scope that
              was registered by this resource server for the referenced
              resource.</t>

              <t hangText="exp">OPTIONAL. Integer timestamp, measured in the
              number of seconds since January 1 1970 UTC, indicating when this
              permission will expire. If the property is absent, the
              permission does not expire. If the token-level <spanx
              style="verb">exp</spanx> value pre-dates a permission-level
              <spanx style="verb">exp</spanx> value, the former overrides the
              latter.</t>

              <t hangText="iat">OPTIONAL. Integer timestamp, measured in the
              number of seconds since January 1 1970 UTC, indicating when this
              permission was originally issued. If the token-level <spanx
              style="verb">iat</spanx> value post-dates a permission-level
              <spanx style="verb">iat</spanx> value, the former overrides the
              latter.</t>

              <t hangText="nbf">OPTIONAL. Integer timestamp, measured in the
              number of seconds since January 1 1970 UTC, indicating the time
              before which this permission is not valid. If the token-level
              <spanx style="verb">nbf</spanx> value post-dates a
              permission-level <spanx style="verb">nbf</spanx> value, the
              former overrides the latter.</t>
            </list></t>

          <figure>
            <preamble>Example:</preamble>

            <artwork><![CDATA[HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store
...

{  
   "active":true,
   "exp":1256953732,
   "iat":1256912345,
   "permissions":[  
      {  
         "resource_id":"112210f47de98100",
         "resource_scopes":[  
            "view",
            "http://photoz.example.com/dev/actions/print"
         ],
         "exp":1256953732
      }
   ]
}
]]></artwork>
          </figure>
        </section>
      </section>

      <section anchor="seek-authorization"
               title="Client Seeks Authorization for Access: The UMA Grant">
        <t>This section describes the mechanisms of the UMA grant type.</t>

        <t>In order to access a protected resource successfully on the
        requesting party&rsquo;s behalf, a client needs to present a valid RPT
        with sufficient permissions. The client uses the token endpoint to
        acquire an RPT and optionally to ask for specific scopes it wants,
        providing the permission ticket it received from the resource server,
        and optionally providing a persisted claims token (PCT) it received
        from this authorization server to optimize the process of seeking a
        new RPT.</t>

        <t>This interaction depends on the following preconditions:<list
            style="symbols">
            <t>The client has obtained a permission ticket and an
            authorization server location from the resource server (see <xref
            target="permission-success-to-client" />).</t>

            <t>This client has discovered the authorization server's
            configuration document and endpoints as needed.</t>

            <t>The client has obtained OAuth client credentials from the
            authorization server. It is OPTIONAL for the client credentials to
            be provided dynamically through <xref target="RFC7591" /> or <xref
            target="OIDCDynClientReg" />; alternatively, they MAY use a static
            process. The client SHOULD register a <spanx
            style="verb">claims_redirect_uri</spanx> (as defined in <xref
            target="claim-redirect" />) with the authorization server, either
            using a static process or through <xref target="RFC7591" /> or
            <xref target="OIDCDynClientReg" />.</t>
          </list></t>

        <section anchor="uma-grant-type"
                 title="Client Request to Authorization Server for Requesting Party Token">
          <t>The client makes a request to the token endpoint by sending the
          following parameters using the <spanx
          style="verb">"application/x-www-form-urlencoded"</spanx> format per
          <xref target="RFC6749" /> Appendix B with a character encoding of
          UTF-8 in the HTTP request entity-body:<list style="hanging">
              <t hangText="grant_type">REQUIRED. MUST be the value <spanx
              style="verb">urn:ietf:params:oauth:grant-type:uma-ticket</spanx>.</t>

              <t hangText="ticket">REQUIRED. The permission ticket.</t>

              <t hangText="rpt">OPTIONAL. If the client had included an RPT in
              its failed access attempt to the resource, it MAY include the
              same RPT here.</t>

              <t hangText="scope">OPTIONAL. A string of space-separated values
              representing the scopes that the client is requesting. [ISSUE:
              What is the relationship between these scopes and multiple
              resources, if the permission ticket maps to such? ISSUE: Provide
              one or more examples of requesting scopes?]</t>

              <t hangText="claim_tokens">OPTIONAL. Claims pushed directly from
              the client to the authorization server. See <xref
              target="claim-push" /> for more information.</t>

              <t hangText="pct">OPTIONAL. If the authorization server
              previously returned a PCT along with an RPT, the client MAY
              include the PCT in order to optimize the process of seeking a
              new RPT. Given that some claims represented by a PCT are likely
              to contain identity information about a requesting party, a
              client supplying a PCT in its RPT request MUST make a best
              effort to ensure that the requesting party using the client now
              is the same as the requesting party that was associated with the
              PCT when it was issued. See <xref target="sec-consid-pct" /> for
              additional PCT security considerations.</t>
            </list></t>

          <figure>
            <preamble>Example of a request message containing a permission
            ticket:</preamble>

            <artwork><![CDATA[POST /token HTTP/1.1
Host: as.example.com
Authorization: Bearer jwfLG53^sad$#f
...
grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Auma-ticket&
ticket=016f84e8-f9b9-11e0-bd6f-0021cc6004de
&rpt=sbjsbhs(/SSJHBSUSSJHVhjsgvhsgvshgsv
]]></artwork>
          </figure>
        </section>

        <section anchor="authorization-assessment"
                 title="Authorization Assessment Process">
          <t>The authorization server uses the permission ticket to look up
          the details of the previously requested set of permissions, maps the
          permissions to operative resource owner policies based on the
          resource identifier and scopes associated with it, potentially
          requests and receives claims, and ultimately responds positively or
          negatively to the request for permissions.</t>

          <t>The authorization server bases the issuance of permissions on
          resource owner policies. Thus, these policies function as
          authorization that has been granted ahead of time. The authorization
          server is also free to enable the resource owner to set policies
          that require the owner to interact with the server to authorize an
          access attempt in near-real time, or to help the resource owner
          field access requests as acts of post hoc authorization. Thus,
          authorization by UMA methods constitutes an asynchronous
          authorization grant. All such processes are outside the scope of
          this specification.</t>

          <t>The authorization server evaluates the policies in light of
          claims and any other information in evidence. The claims MAY have
          come from one or more of three sources: pushed directly by the
          client using the <spanx style="verb">claim_tokens</spanx> parameter
          during the just-previous authorization process, gathered
          interactively at the claims interaction endpoint during the
          just-previous authorization process, or represented by the PCT
          presented by the client in the <spanx style="verb">pct</spanx>
          parameter. The authorization server could have collected the
          additional information by performing out-of-band client or
          requesting party claim lookups in external repositories, or checking
          a variety of other factors that are either dependent on client or
          requesting party context (such as apparent IP address) or
          independent of them (such as time of day).</t>

          <t>Since policies are out of band for UMA and the authorization
          server's policy expression and evaluation capabilities might take a
          simple or arbitrarily complex form, its corresponding abilities to
          combine or perform calculations over claim values might also
          vary.</t>

          <t>Note: If the client incompletely satisfies any policy criteria,
          the authorization server is free either to partially fulfill the
          elements of that request, for example, granting authorization to
          some scopes associated with a requested permission but not all, or
          to reject the request.</t>

          <t>The authorization server MUST use a default-deny authorization
          assessment model in adding permissions to RPTs, that is, "everything
          that is not expressly allowed is forbidden" for resources for which
          resource servers have requested access permission on behalf of
          clients. Exercise caution in implementing default-deny because
          corner cases can inadvertently result in default-permit behavior.
          For example, it is insufficient simply to assume that all resources
          have some non-zero set of claims required for access, and then
          accept an empty set of supplied claims as sufficient for access. See
          <xref target="UMA-Impl" /> for further discussion.</t>
        </section>

        <section anchor="give-rpt"
                 title="Authorization Server Response to Client on Authorization Success">
          <t>If the authorization server's assessment process results in
          issuance of permissions (see <xref
          target="authorization-assessment" />), it returns an HTTP 200 (OK)
          status code with a response body containing the RPT with which it
          has associated the requested permissions.</t>

          <t>Note: The authorization server is free to choose to return either
          the same RPT that appeared in the request or a new RPT, and it is
          also free to choose to invalidate or retain the validity of the
          original RPT or any permission that was previously added to that
          RPT. To assist in client interoperability and token caching
          expectations, it is RECOMMENDED that authorization servers document
          their practices. <xref target="UMA-Impl" /> discusses the
          implications.</t>

          <figure>
            <preamble>Example:</preamble>

            <artwork><![CDATA[HTTP/1.1 200 OK
Content-Type: application/json
... 

{  
   "access_token":"sbjsbhs(/SSJHBSUSSJHVhjsgvhsgvshgsv",
   "token_type":"Bearer"
}
]]></artwork>
          </figure>

          <t>The authorization server MAY include an OAuth refresh token with
          the RPT.</t>

          <section anchor="saved-consent-token"
                   title="Authorization Server Response to Client on Authorization Success with Persisted Claims Token">
            <t>The authorization server MAY return a PCT along with an RPT.
            The PCT represents claims collected during this authorization
            process, either directly or through the claims interaction
            endpoint. The PCT MUST be unguessable by an attacker. The PCT MUST
            NOT disclose claims from the requesting party directly to
            possessors of the PCT. Instead, such claims SHOULD be associated
            by reference to the PCT or expressed in an encrypted format that
            can be decrypted only by the authorization server that issued the
            PCT. See <xref target="interaction-consent" /> for more
            information about the end-user requesting party interaction
            option. See <xref target="sec-consid-pct" /> for additional PCT
            security considerations.</t>

            <t>The PCT MAY be included by the client in future requests to the
            token endpoint using the UMA grant type (see <xref
            target="uma-grant-type" />).</t>

            <figure>
              <preamble>Example:</preamble>

              <artwork><![CDATA[HTTP/1.1 200 OK
Content-Type: application/json
...

{  
   "access_token":"sbjsbhs(/SSJHBSUSSJHVhjsgvhsgvshgsv",
   "token_type":"Bearer",
   "pct":"c2F2ZWRjb25zZW50"
}
]]></artwork>
            </figure>
          </section>
        </section>

        <section anchor="authorization-failure"
                 title="Authorization Server Response to Client on Authorization Failure">
          <t>If the client's request to the token endpoint is not sufficient
          for granting an RPT, the authorization server responds using one of
          the following UMA error codes and corresponding HTTP status codes
          (see <xref target="uma-error-response" /> for more information about
          error codes and responses):<list style="hanging">
              <t hangText="invalid_ticket">The provided ticket was not found
              at the authorization server. The authorization server responds
              with the HTTP 400 (Bad Request) status code.</t>

              <t hangText="expired_ticket">The provided ticket has expired.
              The authorization server responds with the HTTP 400 (Bad
              Request) status code.</t>

              <t hangText="not_authorized">The client is not authorized to
              have these permissions added. The authorization server responds
              with the HTTP 403 (Forbidden) status code.</t>

              <t hangText="invalid_scope">At least one of the scopes included
              in the request does not match an available scope for any of the
              resources associated with requested permissions for the
              permission ticket provided by the client. The authorization
              server responds with the HTTP 400 (Bad Request) status code.</t>

              <t hangText="request_submitted">The authorization server
              requires intervention by the resource owner to determine whether
              the client is authorized to have these permissions. The
              authorization server responds with the HTTP 403 (Forbidden)
              status code.</t>

              <t hangText="need_info">The authorization server needs
              additional information in order to determine whether the client
              is authorized to have these permissions. The authorization
              server responds with the HTTP 403 (Forbidden) status code. It
              MAY also respond with an <spanx
              style="verb">error_details</spanx> object that contains one or
              more sub-properties with hints about the nature of further
              required information. The client then has the opportunity to
              engage in follow-on flows to continue seeking authorization (see
              <xref target="need-info" />).</t>
            </list></t>

          <t>The first five error responses conclude the authorization
          server's interaction with the client, and the client is free to
          attempt access to the protected resource another time. The sixth
          error response, <spanx style="verb">need_info</spanx>, begins or
          continues an authorization process loop that concludes only when the
          client receives one of the other five errors or a success condition
          (as described in <xref target="give-rpt" />).</t>

          <figure>
            <preamble>Example when the ticket has expired:</preamble>

            <artwork><![CDATA[HTTP/1.1 400 Bad Request
Content-Type: application/json
Cache-Control: no-store
...

{  
   "error":"expired_ticket"
}
]]></artwork>
          </figure>

          <figure>
            <preamble>Example of a <spanx style="verb">need_info</spanx>
            response with a full set of <spanx
            style="verb">error_details</spanx> hints:</preamble>

            <artwork><![CDATA[HTTP/1.1 403 Forbidden
Content-Type: application/json
Cache-Control: no-store
...

{  
   "error":"need_info",
   "error_details":{  
      "required_claims":[  
         {  
            "name":"email23423453ou453",
            "friendly_name":"email",
            "claim_type":"urn:oid:0.9.2342.19200300.100.1.3",
            "claim_token_format":[  
               "http://openid.net/specs/openid-connect-core-1_0.html#HybridIDToken"
            ],
            "issuer":[  
               "https://example.com/idp"
            ]
         }
      ],
      "redirect_user":"https://as.example.com/rqp_claims_uri?id=2346576421"
   }
}
]]></artwork>
          </figure>

          <t>The <spanx style="verb">error_details</spanx> object is OPTIONAL
          for the authorization server to provide. It provides hints about
          additional requirements regarding information the authorization
          server needs about the requesting party. On receiving such hints,
          the client has the opportunity to engage, or engage the requesting
          party, with the authorization server in claims collection flows of
          various types. The <spanx style="verb">error_details</spanx>
          sub-property MAY contain the following parameters, where at least
          one of <spanx style="verb">required_claims</spanx> or <spanx
          style="verb">redirect_user</spanx> MUST be supplied.<list
              style="hanging">
              <t hangText="required_claims">An array containing objects that
              describe characteristics of the required claims, with the
              following properties:<list style="hanging">
                  <t hangText="name">OPTIONAL. A string (which MAY be a URI)
                  representing the name of the claim; the "key" in a key-value
                  pair.</t>

                  <t hangText="friendly_name">OPTIONAL. A string that provides
                  a more human-readable form of the attribute's name, which
                  may be useful as a "display name" for use in user interfaces
                  in cases where the actual name is complex or opaque, such as
                  an OID or a UUID.</t>

                  <t hangText="claim_type">OPTIONAL. A string, indicating the
                  expected interpretation of the provided claim value. The
                  string MAY be a URI.</t>

                  <t hangText="claim_token_format">OPTIONAL. An array of
                  strings specifying a set of acceptable formats for a token
                  pushed by the client containing this claim (see <xref
                  target="claim-push" />). Any one of the referenced formats
                  would satisfy the authorization server's requirements. Each
                  string MAY be a URI.</t>

                  <t hangText="issuer">OPTIONAL. An array of strings
                  specifying a set of acceptable issuing authorities for the
                  claim. Any one of the referenced authorities would satisfy
                  the authorization server's requirements. Each string MAY be
                  a URI.</t>
                </list></t>

              <t hangText="redirect_user">OPTIONAL. The claims interaction
              endpoint URI to which to redirect the end-user requesting party
              at the authorization server to continue the process of
              interactive claims gathering. For example, the authorization
              server may require the requesting party to fill out a CAPTCHA to
              help prove humanness. If the requesting party is not an
              end-user, then no client action would be possible on receiving
              the hint. If a static claims interaction endpoint was also
              provided in the authorization server's configuration document,
              then this value overrides the static value. Providing a value in
              this response might be appropriate, for example, if the URI
              needs to be customized per requesting party.</t>

              <t hangText="ticket">A permission ticket that allows the client
              to make further requests to the authorization server during this
              attempted authorization. The value of this permission ticket
              MUST NOT be the same as the one the client used to make its
              request.</t>
            </list></t>

          <t>The authorization server has two options for collecting claims
          through UMA mechanisms: accepting client-pushed claims (see <xref
          target="claim-push" />) and interacting with an end-user requesting
          party to gather claims (see <xref target="claim-redirect" />). See
          <xref target="sec-consid" /> for important security considerations
          regarding claims collection.</t>
        </section>
      </section>

      <section anchor="need-info"
               title="Client Responds to Authorization Server's Request for Additional Information">
        <t>If the client received a <spanx style="verb">need_info</spanx>
        error in response to its request for authorization, it has the
        opportunity to continue the authorization process.</t>

        <t>If an <spanx style="verb">error_details</spanx> object was also
        returned with the error, then the contents of that object indicate the
        flow options.</t>

        <section anchor="claim-push"
                 title="Client Pushes Claim Tokens to Authorization Server">
          <t>If the authorization server can accept pushed claims (for
          example, as it might have indicated by providing <spanx
          style="verb">requesting_party_claims</spanx> hints illustrated in
          <xref target="authorization-failure" />), the client has the option
          to <spanx>push</spanx> claim tokens to the token endpoint. The claim
          token can reflect the client's role as a federated identity
          provider, a federated relying party, or an application integrated
          with a native identity repository.</t>

          <t>If the client is aware of the authorization server's requirements
          for claims through an out-of-band relationship, the client MAY push
          claim tokens in an initial interaction with the token endpoint.</t>

          <t>The client supplies claim tokens in the body of the request
          message by providing, in addition to the <spanx
          style="verb">rpt</spanx> and <spanx style="verb">ticket</spanx>
          properties, the following property:<list style="hanging">
              <t hangText="claim_tokens">REQUIRED. An array of objects with
              the following properties:<list style="hanging">
                  <t hangText="format">REQUIRED. A string specifying the
                  format of the accompanying claim tokens. The string MAY be a
                  URI.</t>

                  <t hangText="token">REQUIRED. A string containing the claim
                  information in the indicated format, base64url encoded if it
                  is not already so encoded. If claim token format features
                  are included that require special interpretation, the client
                  and authorization server are assumed to have a prior
                  relationship that establishes how to interpret these
                  features. For example, if the referenced format equates to
                  SAML 2.0 assertions and the claim token contains audience
                  restrictions, it is the joint responsibility of the client
                  and authorization server to determine the proper audience
                  values that enable successful token consumption (see for
                  <xref target="trust-push" /> relevant security
                  considerations).</t>
                </list></t>
            </list></t>

          <figure>
            <preamble>Example:</preamble>

            <artwork><![CDATA[POST /token HTTP/1.1
Host: www.example.com
Authorization: Bearer jwfLG53^sad$#f
...

{  
   "rpt":"sbjsbhs(/SSJHBSUSSJHVhjsgvhsgvshgsv",
   "ticket":"016f84e8-f9b9-11e0-bd6f-0021cc6004de",
   "claim_tokens":[  
      {  
         "format":"http://openid.net/specs/openid-connect-core-1_0.html#HybridIDToken",
         "token":"..."
      }
   ]
}
]]></artwork>
          </figure>

          <t>This specification provides a framework for extensibility through
          claim token format profiling. The authorization server MAY support
          any number of claim token profiles, and SHOULD document the claim
          token profiles it supports in its configuration document.</t>
        </section>

        <section anchor="claim-redirect"
                 title="Client Redirects Requesting Party to Authorization Server for Claims-Gathering">
          <t>If the authorization server has declared a claims interaction
          endpoint in its configuration document, or if the authorization
          server requires direct interaction with the requesting party as part
          of its claims collection process (for example, as it might have
          indicated through the <spanx style="verb">redirect_user</spanx> hint
          illustrated in <xref target="authorization-failure" />), the client
          has the option to <spanx>redirect</spanx> an end-user requesting
          party to the claims interaction endpoint. In this case, the
          authorization server might be a relying party in a federated
          identity interaction, or it might connect to a directory or other
          user repository, or even interact with the user in other ways, such
          as presenting a questionnaire in a web form. After this process
          completes, the authorization server redirects the end-user
          requesting party back to the client.</t>

          <t>The client constructs the request URI by adding the following
          parameters to the query component of the claims interaction endpoint
          URI using the <spanx
          style="verb">application/x-www-form-urlencoded</spanx> format:<list
              style="hanging">
              <t hangText="client_id">REQUIRED. The client's identifier issued
              by the authorization server.</t>

              <t hangText="claims_redirect_uri">OPTIONAL. The URI to which the
              client wishes the authorization server to direct the requesting
              party's user agent after completing its interaction. The URI
              MUST be absolute, MAY contain an <spanx
              style="verb">application/x-www-form-urlencoded</spanx>-formatted
              query parameter component that MUST be retained when adding
              additional parameters, and MUST NOT contain a fragment
              component. The authorization server SHOULD require all clients
              to register their redirection endpoint prior to utilizing the
              authorization endpoint (either using a static process or through
              <xref target="RFC7591" /> or <xref
              target="OIDCDynClientReg" />). Claims redirection URIs are
              different from the redirection URIs defined in <xref
              target="RFC6749" /> in that they are intended for the exclusive
              use of requesting parties and not resource owners. Therefore,
              authorization servers MUST NOT redirect requesting parties to
              pre-registered redirection URIs defined in <xref
              target="RFC6749" /> unless such URIs are also pre-registered
              specifically as claims redirection URIs. If the URI is
              pre-registered, this URI MUST exactly match one of the
              pre-registered claims redirection URIs, with the matching
              performed as described in Section 6.2.1 of <xref
              target="RFC3986" /> (Simple String Comparison).</t>

              <t hangText="ticket">REQUIRED. The latest permission ticket
              associated with the client's current request an RPT for this
              requesting party.</t>

              <t hangText="state">RECOMMENDED. An opaque value used by the
              client to maintain state between the request and callback. The
              authorization server includes this value when redirecting the
              user agent back to the client. The use of this parameter is for
              preventing cross-site request forgery.</t>
            </list></t>

          <figure>
            <preamble>Example of a request issued by a client application
            (line breaks are shown only for display convenience):</preamble>

            <artwork><![CDATA[GET /rqp_claims?client_id=some_client_id&state=abc
&ticket=016f84e8-f9b9-11e0-bd6f-0021cc6004de
&claims_redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fredirect_claims HTTP/1.1
Host: as.example.com
]]></artwork>
          </figure>

          <t>At the conclusion of its interaction with the requesting party,
          the authorization server returns the user agent to the client adding
          the following parameters to the query component of the claims
          redirection URI using the <spanx
          style="verb">application/x-www-form-urlencoded</spanx> format:<list
              style="hanging">
              <t hangText="authorization_state">REQUIRED. Indicates that the
              authorization server completed its claims-gathering interaction
              with the requesting party with the indicated state:<list
                  style="hanging">
                  <t hangText="claims_submitted">The client is free to return
                  to the token endpoint to seek permissions once again.</t>

                  <t hangText="not_authorized">The client is not authorized to
                  have the desired permissions added.</t>

                  <t hangText="need_info">The authorization server needs
                  additional information in order to determine whether the
                  client is authorized to have these permissions. This
                  response directs the client to return to the token endpoint,
                  where it might be provided with <spanx
                  style="verb">error_details</spanx> hints about additional
                  information needed.</t>

                  <t hangText="request_submitted">The authorization server
                  requires intervention by the resource owner to determine
                  whether permissions can be added. Further immediate
                  interaction between the client, requesting party, and
                  authorization server is out of scope of this
                  specification.</t>
                </list></t>

              <t hangText="ticket">OPTIONAL. A permission ticket that allows
              the client to make further requests to the authorization server
              during this attempted authorization. The value of this
              permission ticket MUST NOT be the same as the one the client
              used to make its request.</t>

              <t hangText="state">OPTIONAL. The same state value that the
              client provided in the request. It MUST be present if and only
              if the client provided it.</t>
            </list></t>

          <t>The client MUST ignore unrecognized response parameters. If the
          request fails due to a missing, invalid, or mismatching claims
          redirection URI, or if the client identifier is missing or invalid,
          the authorization server SHOULD inform the resource owner of the
          error and MUST NOT automatically redirect the user agent to the
          invalid redirection URI. If the request fails for reasons other than
          a missing or invalid claims redirection URI, the authorization
          server informs the client by adding an <spanx
          style="verb">error</spanx> parameter to the query component of the
          claims redirection URI using the <spanx
          style="verb">application/x-www-form-urlencoded</spanx> format,
          containing one of the following ASCII error codes:<list
              style="hanging">
              <t hangText="invalid_request">The request is missing a required
              parameter, includes an invalid parameter value (such as an
              invalid or expired ticket), includes a parameter more than once,
              or is otherwise malformed.</t>

              <t hangText="server_error">The authorization server encountered
              an unexpected condition that prevented it from fulfilling the
              request. (This error code is needed because an HTTP 500
              (Internal Server Error) status code cannot be returned to the
              client via an HTTP redirect.)</t>

              <t hangText="temporarily_unavailable">The authorization server
              is currently unable to handle the request due to a temporary
              overloading or maintenance of the server. (This error code is
              needed because an HTTP 503 (Service Unavailable) status code
              cannot be returned to the client via an HTTP redirect.)</t>
            </list></t>

          <figure>
            <preamble>Example of a response issued by an authorization server
            (line breaks are shown only for display convenience):</preamble>

            <artwork><![CDATA[GET /redirect_claims?&state=abc
&authorization_state=claims_submitted HTTP/1.1
Host: client.example.com
]]></artwork>
          </figure>

          <section anchor="interaction-consent"
                   title="Authorization Server Gathers Requesting Party Authorization for Trust Elevation by Client: Persisted Claims">
            <t>As noted in <xref target="saved-consent-token" />, the
            authorization server MAY choose to persist collected claims and
            issue a PCT in order to optimize future authorization processes on
            behalf of a requesting party. It MAY also gather authorization
            from an end-user requesting party for persisting these claims, one
            option being persisting this authorization in the form of an
            actual claim itself.</t>

            <t>The authorization server MAY combine authorization-gathering
            interaction with other interactions as necessary, and in any
            order. For example, the authorization server might present an
            opportunity for the requesting party to create or manage a login
            account for more persistent storage of gathered and pushed claims
            over time.</t>
          </section>
        </section>
      </section>
    </section>

    <section anchor="errors" title="Error Messages">
      <t>Both OAuth and UMA errors can occur.</t>

      <section anchor="oauth-error-response" title="OAuth Error Responses">
        <t>As described in <xref target="protection-api" />, the protection
        API requires a PAT for access. PATs are simply OAuth access tokens
        with appropriate scope. If a request to an endpoint in this API fails
        due to an invalid, missing, or expired access token, or requires
        higher privileges at this endpoint than provided by the token
        supplied, the authorization server responds with an OAuth error.</t>
      </section>

      <section anchor="uma-error-response" title="UMA Error Responses">
        <t>If a request triggers no OAuth error, but is invalid for another
        reason as defined throughout this specification, the authorization
        server or resource server responds with an UMA error, sometimes along
        with a specified HTTP status code, by supplying the following
        properties in a JSON-encoded object in the body of the HTTP response:
        <list style="hanging">
            <t hangText="error">REQUIRED. A single error code. Values for this
            property are defined throughout this specification.</t>

            <t hangText="error_description">OPTIONAL. Human-readable text
            providing additional information.</t>

            <t hangText="error_uri">OPTIONAL. A URI identifying a
            human-readable web page with information about the error.</t>
          </list></t>

        <t>The following is a common error code that applies to several
        UMA-specified request messages: <list style="hanging">
            <t hangText="invalid_request">The request is missing a required
            parameter, includes an invalid parameter value, includes a
            parameter more than once, or is otherwise malformed. The
            authorization server MUST respond with the HTTP 400 (Bad Request)
            status code.</t>
          </list></t>

        <figure>
          <preamble>For example:</preamble>

          <artwork><![CDATA[HTTP/1.1 400 Bad Request
Content-Type: application/json
Cache-Control: no-store
...

{  
   "error":"invalid_request",
   "error_description":"Request is missing a required parameter.",
   "error_uri":"https://as.example.com/errors/bad_uma_request"
}
]]></artwork>
        </figure>
      </section>
    </section>

    <section anchor="comms-profiles" title="Profiles for API Extensibility">
      <t>In some circumstances, it may be desirable to couple UMA software
      entity roles tightly. For example, an authorization server application
      might also need to act as a client application in order to retrieve
      protected resources so that it can present to resource owners a
      dashboard-like user interface that accurately guides the setting of
      policy; it might need to access itself-as-authorization server for that
      purpose. For another example, the same organization might operate both
      an authorization server and a resource server that communicate only with
      each other behind a firewall, and it might seek more efficient
      communication methods between them.</t>

      <t>In other circumstances, it may be desirable to bind UMA flows to
      transport mechanisms other than HTTP even if entities remain loosely
      coupled. For example, in Internet of Things scenarios, Constrained
      Application Protocol (CoAP) may be preferred over HTTP.</t>

      <t>This section defines profiles that allow inter-role communications
      channels and methods to vary in these circumstances. This specification
      still REQUIRES authorization servers to issue PATs, and RPTs and
      associate permissions with RPTs, and REQUIRES resource servers not to
      give access in the case of an invalid RPT or an RPT associated with
      insufficient authorization. This is because, although tokens might not
      always appear on the wire in the normal fashion, the tokens may
      represent sets of expected behaviors of additional parties unable to
      take part in these optimization opportunities.</t>

      <t>Where alternate communications channels are being used between
      independently implemented system entities, it is RECOMMENDED, for
      reasons of implementation interoperability, to define concrete extension
      profiles that build on these extensibility profiles (see <xref
      target="uma-profiles" />).</t>

      <section anchor="alt-prot-profile"
               title="Protection API Extensibility Profile">
        <t>This section defines a profile for UMA where the authorization
        server and resource server roles either reside in the same system
        entity or otherwise have a privileged or specialized communications
        channel between them. Following is a summary:<list style="symbols">
            <t>Identifying URI:
            https://docs.kantarainitiative.org/uma/profiles/prot-ext-1.0</t>

            <t>Profile author and contact information: Mark Dobrinic
            (mdobrinic@cozmanova.com)</t>

            <t>Updates or obsoletes: None; this profile is new.</t>

            <t>Security considerations: See below.</t>

            <t>Privacy considerations: See below.</t>

            <t>Error states: None additional.</t>
          </list></t>

        <t>Using this profile, the resource server MAY use means other than
        the HTTP-based protection API that is protected by TLS and OAuth (or
        an OAuth-based authentication protocol) to communicate with the
        authorization server in all respects, including using software
        interfaces and methods rather than network interfaces and APIs. The
        authorization server MUST still issue PATs and RPTs and associate
        permissions with RPTs, and the resource server still MUST NOT give
        clients access in the case of invalid RPTs or RPTs that are associated
        with insufficient permissions. Interactions with entities other than
        the authorization server or resource server MUST be preserved exactly
        as they would have if either of them were using standardized UMA APIs,
        unless other extensibility profiles are also in use.</t>

        <t>An authorization server using any of the opportunities afforded by
        this profile MUST declare use of this profile by supplying its
        identifying URI for one of its <spanx
        style="verb">uma_profiles_supported</spanx> values in its
        configuration document (see <xref target="am-endpoints" />).</t>

        <t>Same-entity communication or a tight integration of entities has
        the opportunity to make deployments more secure by reducing possible
        attack vectors. However, if the entities do not use TLS but
        communicate across a transport layer, it is RECOMMENDED to use an
        alternate means of transport-layer security, for example, using DTLS
        in the case of a CoAP-based UMA profile.</t>

        <t>Same-entity communication or a tight integration of entities has
        the potential to compromise privacy by promoting the freer exchange of
        personal information within a deployment ecosystem. It is RECOMMENDED
        to account for privacy impacts in each deployment scenario.</t>
      </section>

      <section anchor="alt-authz-profile"
               title="Authorization API Extensibility Profile">
        <t>This section defines a profile for UMA where the authorization
        server and client roles either reside in the same system entity or
        otherwise have a privileged or specialized communications channel
        between them. Following is a summary:<list style="symbols">
            <t>Identifying URI:
            https://docs.kantarainitiative.org/uma/profiles/authz-ext-1.0</t>

            <t>Profile author and contact information: Mark Dobrinic
            (mdobrinic@cozmanova.com)</t>

            <t>Updates or obsoletes: None; this profile is new.</t>

            <t>Security considerations: See below.</t>

            <t>Privacy considerations: See below.</t>

            <t>Error states: None additional.</t>
          </list></t>

        <t>Using this profile, the client MAY use means other than the
        HTTP-based authorization API that is protected by TLS and OAuth (or an
        OAuth-based authentication protocol) to communicate with the
        authorization server in all respects, including using software
        interfaces and methods rather than network interfaces and APIs. The
        authorization server MUST still issue PATs and RPTs and associate
        permissions with RPTs, and the resource server still MUST NOT give
        clients access in the case of invalid RPTs or RPTs that are associated
        with insufficient permissions. Interactions with entities other than
        the authorization server or client MUST be preserved exactly as they
        would have if either of them were using standardized UMA APIs, unless
        other extensibility profiles are also in use.</t>

        <t>An authorization server using any of the opportunities afforded by
        this profile MUST declare use of this profile by supplying its
        identifying URI for one of its <spanx
        style="verb">uma_profiles_supported</spanx> values in its
        configuration document (see <xref target="am-endpoints" />).</t>

        <t>Same-entity communication or a tight integration of entities has
        the opportunity to make deployments more secure by reducing possible
        attack vectors. However, if the entities do not use TLS but
        communicate across a transport layer, it is RECOMMENDED to use an
        alternate means of transport-layer security, for example, using DTLS
        in the case of a CoAP-based UMA profile.</t>

        <t>Same-entity communication or a tight integration of entities has
        the potential to compromise privacy by promoting the freer exchange of
        personal information within a deployment ecosystem. It is RECOMMENDED
        to account for privacy impacts in each deployment scenario.</t>
      </section>

      <section anchor="alt-resource-profile"
               title="Resource Interface Extensibility Profile">
        <t>This section defines a profile for UMA where the resource server
        and client roles either reside in the same system entity or otherwise
        have a privileged or specialized communications channel between them.
        Following is a summary:<list style="symbols">
            <t>Identifying URI:
            https://docs.kantarainitiative.org/uma/profiles/rsrc-ext-1.0</t>

            <t>Profile author and contact information: Mark Dobrinic
            (mdobrinic@cozmanova.com)</t>

            <t>Updates or obsoletes: None; this profile is new.</t>

            <t>Security considerations: See below.</t>

            <t>Privacy considerations: See below.</t>

            <t>Error states: None additional.</t>
          </list></t>

        <t>Using this profile, the resource server MAY use means other than an
        HTTP-based resource interface to communicate with the authorization
        server in all respects, including using software interfaces and
        methods rather than network interfaces and APIs. The resource server
        still MUST NOT give clients access in the case of invalid RPTs or RPTs
        that are associated with insufficient permissions. Interactions with
        entities other than the resource server or client MUST be preserved
        exactly as they would have if either of them were using standardized
        UMA APIs, unless other extensibility profiles are also in use.</t>

        <t>An authorization server involved in deployments where resource
        servers and clients are known to be using opportunities afforded by
        the resource interface extensibility profile MAY declare use of this
        profile by supplying its identifying URI for one of its <spanx
        style="verb">uma_profiles_supported</spanx> values in its
        configuration document (see <xref target="am-endpoints" />).</t>

        <t>Same-entity communication or a tight integration of entities has
        the opportunity to make deployments more secure by reducing possible
        attack vectors. However, if the entities do not use TLS but
        communicate across a transport layer, it is RECOMMENDED to use an
        alternate means of transport-layer security, for example, using DTLS
        in the case of a CoAP-based UMA profile.</t>

        <t>Same-entity communication or a tight integration of entities has
        the potential to compromise privacy by promoting the freer exchange of
        personal information within a deployment ecosystem. It is RECOMMENDED
        to account for privacy impacts in each deployment scenario.</t>
      </section>
    </section>

    <section anchor="profiles" title="Specifying Additional Profiles">
      <t>This specification defines a protocol that has optional features. For
      implementation interoperability and to serve particular deployment
      scenarios, including sector-specific ones such as healthcare or
      e-government, third parties may want to define profiles of UMA that
      restrict these options.</t>

      <t>Further, this specification creates extensibility points for RPT
      profiles and claim token profiles, and third parties may likewise want
      to define their own. Different RPT profiles could be used, for example,
      to change the dividing line between authorization server and resource
      server responsibilities in controlling access. Different claim token
      profiles could be used to customize sector-specific or
      population-specific (such as individual vs. employee) claim types that
      drive the types of policies resource owners could set.</t>

      <t>It is not practical for this specification to standardize all desired
      profiles. However, to serve overall interoperability goals, this section
      provides guidelines for third parties that wish to specify UMA-related
      profiles. In all cases, it is RECOMMENDED that profiles document the
      following information:<list style="symbols">
          <t>Specify a URI that uniquely identifies the profile.</t>

          <t>Identify the responsible author and provide postal or electronic
          contact information.</t>

          <t>Supply references to any previously defined profiles that the
          profile updates or obsoletes.</t>

          <t>Define any additional or changed error states.</t>

          <t>Specify any conformance and interoperability considerations.</t>

          <t>Supply any security and privacy considerations additional to
          <xref target="sec-consid" />.</t>
        </list></t>

      <section anchor="uma-profiles" title="Specifying Profiles of UMA">
        <t>It is RECOMMENDED that profiles of UMA additionally document the
        following information:</t>

        <t>
          <list style="symbols">
            <t>Specify the set of interactions between endpoint entities
            involved in the profile, calling out any restrictions on ordinary
            UMA operations and any extension properties used in message
            formats.</t>
          </list>
        </t>

        <t>See <xref target="comms-profiles" /> for examples.</t>
      </section>

      <section anchor="rpt-profiles" title="Specifying RPT Profiles">
        <t>It is RECOMMENDED that RPT profiles additionally document the
        following information:</t>

        <t>
          <list style="symbols">
            <t>Specify the keyword to be used in HTTP Authorization headers
            with tokens conforming to this profile.</t>

            <t>Specify the syntax and semantics of the data that the
            authorization server associates with the token.</t>

            <t>Specify how the token data is associated with, contained
            within, and/or retrieved by means of, the on-the-wire token
            string.</t>

            <t>Specify processing rules for token data.</t>

            <t>Identify any restrictions on grant types to be used with the
            token profile.</t>
          </list>
        </t>

        <t>See <xref target="uma-bearer-token-profile" /> for an example.</t>
      </section>

      <section anchor="claim-profiles"
               title="Specifying Claim Token Format Profiles">
        <t>It is RECOMMENDED that claim token format profiles additionally
        document the following information:<list style="symbols">
            <t>Specify any related or additional <spanx
            style="verb">error_details</spanx> hints.</t>

            <t>Specify any constraints on the claim token format vs. a
            standard definition for it in a specification.</t>

            <t>Specify any mutual interpretation details of claim token
            formats by authorization servers and clients.</t>
          </list></t>
      </section>
    </section>

    <section anchor="sec-consid" title="Security Considerations">
      <t>As a profile of OAuth, this specification relies mainly on OAuth
      security mechanisms as well as transport-level encryption. Thus,
      implementers are strongly advised to read <xref target="BCP195" /> and
      the security considerations in <xref target="RFC6749" /> (Section 10)
      and <xref target="RFC6750" /> (Section 5) along with the security
      considerations of any other OAuth token-defining specifications in use,
      along with the entire <xref target="RFC6819" /> specification, and apply
      the countermeasures described therein. As well, since this specification
      builds on <xref target="OAuth-resource-reg" />, implementers should also
      take into account the security considerations in that specification.</t>

      <t>The following sections describe additional security
      considerations.</t>

      <section anchor="rqp-threats" title="Requesting Party Threats">
        <t>This section discusses threats related to UMA's nature as a
        protocol enabling party-to-party sharing of protected resource access;
        that is, enabling requesting parties who are not the resource owner to
        gain authorized access to protected resources.</t>

        <t>For privacy considerations related to requesting parties, see <xref
        target="rqp-privacy" />.</t>

        <section anchor="redirect-threats"
                 title="Requesting Party Redirection and Impersonation">
          <t>Like ordinary OAuth redirection, UMA redirection for the purpose
          of gathering claims from an end-user requesting party (described in
          <xref target="claim-redirect" />) creates the potential for
          cross-site request forgery (CSRF) through an open redirect if the
          authorization server does not force the client to pre-register its
          claims redirection endpoint, and server-side artifact tampering if
          the client does not avail itself of the state parameter. The client
          SHOULD check that the ticket value returned by an authorization
          server after a claims redirect is completed has not been maliciously
          changed, for example by a man in the browser, by using the state
          parameter. (See <xref target="UMA-Impl" /> for advice on ways to
          accomplish this.) Sections 4.4.1.8, 4.4.2.5, and 5.3.5 of <xref
          target="RFC6819" /> are apropos for the UMA claims-gathering
          redirection flow as well.</t>

          <t>When a client redirects an end-user requesting party to the
          claims interaction endpoint, the client provides no a priori context
          to the authorization server about which user is appearing at the
          endpoint, other than implicitly through the permission ticket. Since
          the authorization server is free to gather any claims it wishes, the
          effect is to "late-bind" them to the permission ticket and the state
          string provided by the client, with the effect of enabling the
          authorization server not to trust client-asserted claims. This is a
          desirable result and reflects one reason why the authorization
          server might choose to demand use of the redirect flow over the push
          flow. However, the client has the opportunity to switch end-users --
          say, enabling malicious end-user Carlos to impersonate the original
          end-user Bob, who might be represented by a PCT already in that
          client's possession and might even have authorized the issuance of
          that PCT -- after the redirect completes and before it returns to
          the token endpoint to seek permissions.</t>

          <t>Another issue concerns the exposure of a <spanx
          style="verb">Bearer</spanx>-type RPT to a requesting party, which
          could maliciously pass the token to an unauthorized party.</t>

          <t>To mitigate requesting-party switching and RPT exposure threats,
          consider the following strategies.<list style="symbols">
              <t>Require that the requesting party legitimately represent the
              wielder of the bearer token on a legal or contractual level.
              This solution does not reduce the risk from a technical
              perspective.</t>

              <t>The authorization server, possibly with input from the
              resource owner, can implement tighter time-to-live strategies
              around the permissions in RPTs. This is a classic approach with
              bearer tokens that helps to limit a malicious party's ability to
              intercept and use the bearer token. In the same vein, the
              authorization server could require claims to have a reasonable
              degree of freshness (which would require a custom claims
              profile).</t>

              <t>A stronger strategy is to gather claims interactively from an
              end-user requesting party that demonstrate that some
              sufficiently strong level authentication was performed.</t>

              <t>The strongest strategy is to disallow <spanx
              style="verb">Bearer</spanx>-type RPTs within the UMA profile
              being deployed, by providing or requiring an RPT profile that
              requires use of a holder-of-key approach. In this way, the
              wielder of the token must engage in a live session for
              proof-of-possession.</t>
            </list></t>
        </section>

        <section anchor="sec-consid-pct"
                 title="Requesting Party Claims and Persisted Claim Tokens">
          <t>A PCT is similar to a refresh token in that it carries extra
          power over the usage of an RPT. The authorization server and client
          MUST keep PCTs confidential in transit and storage, and MUST NOT
          share any PCT with any other entity other than the issuer or issued
          client, respectively. The authorization server MUST maintain the
          binding between a PCT and the client to which it was issued.</t>

          <t>Given that a PCT represents a set of requesting party claims, a
          client supplying a PCT in its RPT request MUST make a best effort to
          ensure that the requesting party using the client now is the same as
          the requesting party that was associated with the PCT when it was
          issued. Different clients will have different capabilities in this
          respect; for example, some applications are single-user and perform
          no local authentication, associating all PCTs with the "current
          user", while others might have more sophisticated authentication and
          user mapping capabilities.</t>
        </section>
      </section>

      <section anchor="sec-consid-oauth-oidc"
               title="OAuth- and OpenID Connect-Related Security Considerations">
        <t>This section discusses security considerations related to UMA's use
        of OAuth and OpenID Connect.</t>

        <section title="Strengthening Client Authentication Using OpenID Connect">
          <t>Along with requiring TLS, UMA requires OAuth, or any OAuth-based
          authentication protocol, as the security mechanism for its
          protection API. The UMA resource server thus acts in the role of an
          OAuth client at the authorization server's protection API. While it
          is possible to use any profile of OAuth for this protection, it is
          RECOMMENDED for the authorization server to use OpenID Connect, and
          to use its mechanisms for stronger client authentication at the
          token endpoint, in order to strengthen the authentication of OAuth
          clients. Section 16 of <xref target="OIDCCore" /> provides more
          information on OpenID Connect security considerations.</t>
        </section>

        <section title="Interacting with Resource Owners and Requesting Parties Using OAuth's Implicit Grant Type">
          <t>Clients using the OAuth implicit grant type carry particular
          vulnerabilities in OAuth, and using OpenID Connect is of no help in
          this circumstance. This is true where an UMA resource server is used
          as an OAuth client for obtaining a PAT on a resource owner's behalf,
          and also where an authorization server is gathering claims from a
          requesting party through OAuth.</t>

          <t>For example, an "implicit client" might require the retrieval of
          PATs more frequently, for each browser on each platform. An attacker
          can initiate a spear phishing attack on the resource owner with a
          link to a malicious website, relying on the resource owner to
          authenticate to the authorization server through an email-based
          identity provider in order to receive the PAT. The site can
          impersonate the resource owner using the browser client's client ID
          in an OpenID Connect implicit request to the UMA authorization
          server. If the resource owner had previously authorized a PAT to be
          issued, this attempt will likely succeed. The subsequently issued
          PAT could be used for resource registration and other protection API
          tasks.</t>

          <t>A number of mitigation strategies are possible.<list
              style="symbols">
              <t>The authorization server could penalize or disallow use of
              the implicit grant flow. This could be done at a variety of
              levels:<list style="symbols">
                  <t>Enabling resource owners to define policies controlling
                  the use of such clients</t>

                  <t>Setting system-default policies controlling their use</t>

                  <t>Participating in mutual agreements with other parties,
                  for example, through the definition and mandated use of
                  profiles, that admit only suitably secure client
                  applications to interact with service operators</t>
                </list></t>

              <t>The authorization server could support dynamic client
              registration at the client instance level, such that each
              instance receives a unique client_id and secret. The client can
              then use the authorization code flow and have at least some form
              of client authentication. However, this is easier for a mobile
              app than for a browser-based HTML app.</t>
            </list></t>
        </section>
      </section>

      <section anchor="cred-guessing" title="Credentials-Guessing">
        <t>The authorization server MUST prevent attackers from guessing
        permission tickets and PCTs.</t>
      </section>

      <section title="JSON Usage">
        <t>This specification defines a number of data formats based on <xref
        target="RFC7159" />. As a subset of the JavaScript scripting language,
        JSON data SHOULD be consumed through a process that does not
        dynamically execute it as code, to avoid malicious code execution. One
        way to achieve this is to use a JSON parser rather than the built-in
        JavaScript eval() function.</t>
      </section>

      <section anchor="trust-considerations"
               title="Profiles and Trust Establishment">
        <t>Parties operating and using UMA software entities have
        opportunities to establish agreements about the parties' rights and
        responsibilities on a legal or contractual level, along with common
        interpretations of UMA constructs for consistent and expected software
        behavior. These agreements can be used to improve the parties'
        respective security postures, and written profiles are a key mechanism
        for conveying and enforcing these agreements. <xref
        target="profiles" /> discusses profiling. <xref
        target="comms-profiles" /> discusses profiling for extensibility.</t>

        <section anchor="trust-push"
                 title="Requirements for Trust When Clients Push Claim Tokens">
          <t>This section discusses the threats surrounding client claim
          pushing (see <xref target="claim-push" />).</t>

          <t>Because claim tokens of any format typically contain audience
          restrictions and an authorization server would typically not be in
          the primary audience for a claim token held or generated by a
          client, it is RECOMMENDED to document how the client, authorization
          server, and any additional ecosystem entities and parties will
          establish a trust relationship and communicate any required keying
          material in a claim token format profile, as described in <xref
          target="profiles" /> and <xref target="claim-profiles" />.
          Authorization servers are RECOMMENDED not to accept claim tokens
          pushed by untrusted clients and not to ignore audience restrictions
          found in claim tokens pushed by clients.</t>

          <t>In the special circumstance when an authorization server is
          colocated with an OpenID Provider for the requesting parties within
          a deployment ecosystem, then it is able to act as an OpenID Relying
          Party for itself. This circumstance presents an opportunity for a
          technical optimization of the requirement for trust because the
          authorization server itself issued the client credentials for the
          client in question, and could reasonably be the singular <spanx
          style="verb">aud</spanx> value target in an OpenID Connect ID Token
          pushed by the client to the token endpoint.</t>
        </section>
      </section>
    </section>

    <section anchor="priv-consid" title="Privacy Considerations">
      <t>UMA has the following privacy considerations.</t>

      <section title="Resource Set Information at the Authorization Server">
        <t>The authorization server comes to be in possession of resource
        information that may reveal information about the resource owner,
        which the authorization server's trust relationship with the resource
        server is assumed to accommodate. However, the client is a
        less-trusted party -- in fact, entirely untrustworthy until
        permissions are associated with its RPT. The more information about a
        resource that is registered, the more risk of privacy compromise there
        is through a less-trusted authorization server.</t>
      </section>

      <section anchor="rqp-privacy"
               title="Requesting Party Information at the Authorization Server">
        <t>The primary privacy duty of UMA's design is to the resource owner.
        However, privacy considerations affect the requesting party as well.
        This can be seen in the optional issuance of a PCT, which enables an
        opportunity to optimize an access-seeking flow for a requesting party
        through persisting a set of collected claims across authorization
        processes, and can involve a requesting party's authorization for this
        persistence. Claims are likely to contain personally identifiable and
        possibly very sensitive information, and much like identity attributes
        exchanged during single sign-on, the process of claim pushing in
        particular will tend to be invisible to an end-user requesting party
        if they have not consciously authorized the possibility. A requesting
        party who provides claims to an authorization server once redirected
        there is less susceptible to privacy-destroying behavior.</t>
      </section>

      <section title="Profiles and Trust Establishment">
        <t>Parties operating and using UMA software entities have
        opportunities to establish agreements about mutual rights,
        responsibilities, and common interpretations of UMA constructs for
        consistent and expected software behavior. These agreements can be
        used to improve the parties' respective privacy postures. See <xref
        target="trust-considerations" /> for more information. Additional
        considerations related to Privacy by Design concepts are discussed in
        <xref target="UMA-PbD" />.</t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This document makes the following requests of IANA.</t>

      <section title="JSON Web Token Claims Registration">
        <t>This specification registers the claim defined in <xref
        target="uma-bearer-token-profile" />.</t>

        <section title="Registry Contents">
          <t>
            <list style="symbols">
              <t>Claim name: permissions</t>

              <t>Claim description: Array of objects, each describing a set of
              scoped, time-limitable entitlements to a resource</t>

              <t>Change controller: Kantara Initiative User-Managed Access
              Work Group - wg-uma@kantarainitiative.org</t>

              <t>Specification document: <xref
              target="uma-bearer-token-profile" /> in this document</t>
            </list>
          </t>
        </section>
      </section>

      <section title="OAuth Token Introspection Response Registration">
        <t>This specification registers the claim defined in <xref
        target="uma-bearer-token-profile" />.</t>

        <section title="Registry Contents">
          <t>
            <list style="symbols">
              <t>Name: permissions</t>

              <t>Description: Array of objects, each describing a set of
              scoped, time-limitable entitlements to a resource</t>

              <t>Change controller: Kantara Initiative User-Managed Access
              Work Group - wg-uma@kantarainitiative.org</t>

              <t>Specification document: <xref
              target="uma-bearer-token-profile" /> in this document</t>
            </list>
          </t>
        </section>
      </section>

      <section title="Well-Known URI Registration">
        <t>This specification registers the well-known URI defined in <xref
        target="am-endpoints" />.</t>

        <section title="Registry Contents">
          <t>
            <list style="symbols">
              <t>URI suffix: uma2-configuration</t>

              <t>Change controller: Kantara Initiative User-Managed Access
              Work Group - wg-uma@kantarainitiative.org</t>

              <t>Specification document: <xref target="am-endpoints" /> in
              this document</t>
            </list>
          </t>
        </section>
      </section>
    </section>

    <section anchor="Acknowledgments" title="Acknowledgments">
      <t>The following people made significant text contributions to the
      specification:<list style="symbols">
          <t>Paul C. Bryan, ForgeRock US, Inc. (former editor)</t>

          <t>Domenico Catalano, Oracle (former author)</t>

          <t>Mark Dobrinic, Cozmanova</t>

          <t>George Fletcher, AOL</t>

          <t>Thomas Hardjono, MIT (former editor)</t>

          <t>Lukasz Moren, Cloud Identity Ltd</t>

          <t>Christian Scholz, COMlounge GmbH (former editor)</t>

          <t>Mike Schwartz, Gluu</t>

          <t>Jacek Szpot, Newcastle University</t>
        </list></t>

      <t>Additional contributors to this specification include the Kantara UMA
      Work Group participants, a list of whom can be found at <xref
      target="UMAnitarians" />.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="BCP195" target="https://tools.ietf.org/html/bcp195">
        <front>
          <title>Recommendations for Secure Use of Transport Layer Security
          (TLS) and Datagram Transport Layer Security (DTLS)</title>

          <author initials="Y." surname="Sheffer">
            <organization />
          </author>

          <date day="" month="May" year="2015" />
        </front>
      </reference>

      <reference anchor="OAuth-resource-reg"
                 target="https://docs.kantarainitiative.org/uma/rec-oauth-resource-reg-v1_0_1.html">
        <front>
          <title>OAuth 2.0 Resource Registration</title>

          <author initials="T." surname="Hardjono">
            <organization>IETF</organization>
          </author>

          <date day="28" month="December" year="2015" />
        </front>
      </reference>

      <reference anchor="OIDCCore"
                 target="http://openid.net/specs/openid-connect-core-1_0.html">
        <front>
          <title>OpenID Connect Core 1.0 incorporating errata set 1</title>

          <author initials="N." surname="Sakimura">
            <organization />
          </author>

          <date day="8" month="November" year="2014" />
        </front>
      </reference>

      <reference anchor="OIDCDynClientReg"
                 target="http://openid.net/specs/openid-connect-registration-1_0.html">
        <front>
          <title>OpenID Connect Dynamic Client Registration 1.0 incorporating
          errata set 1</title>

          <author initials="N." surname="Sakimura">
            <organization>OpenID Foundation</organization>
          </author>

          <date day="8" month="November" year="2014" />
        </front>
      </reference>

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119"?>

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986"?>

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5785"?>

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6415"?>

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6711"?>

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749"?>

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6750"?>

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6819"?>

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7159"?>

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7519"?>

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7591"?>

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7662"?>
    </references>

    <references title="Informative References">
      <reference anchor="UMA-casestudies"
                 target="https://kantarainitiative.org/confluence/display/uma/Case+Studies">
        <front>
          <title>UMA Case Studies</title>

          <author initials="E." surname="Maler">
            <organization />
          </author>

          <date day="" month="" year="2016" />
        </front>
      </reference>

      <reference anchor="UMA-Impl"
                 target="https://kantarainitiative.org/confluence/display/uma/UMA+Implementer%27s+Guide">
        <front>
          <title>UMA Implementer's Guide</title>

          <author initials="E." surname="Maler" />

          <date day="" month="" year="2016" />
        </front>
      </reference>

      <reference anchor="UMA-PbD"
                 target="https://kantarainitiative.org/confluence/display/uma/Privacy+by+Design+Implications+of+UMA">
        <front>
          <title>Privacy by Design Implications of UMA</title>

          <author initials="E." surname="Maler" />

          <date day="9" month="December" year="2013" />
        </front>
      </reference>

      <reference anchor="UMA-usecases"
                 target="https://kantarainitiative.org/confluence/display/uma/UMA+Scenarios+and+Use+Cases">
        <front>
          <title>UMA Scenarios and Use Cases</title>

          <author initials="E." surname="Maler">
            <organization>Kantara</organization>
          </author>

          <date day="5" month="October" year="2010" />
        </front>
      </reference>

      <reference anchor="UMAnitarians"
                 target="https://kantarainitiative.org/confluence/display/uma/Participant+Roster">
        <front>
          <title>UMA Participant Roster</title>

          <author initials="E." surname="Maler">
            <organization>Maler</organization>
          </author>

          <date day="" month="" year="2016" />
        </front>
      </reference>
    </references>
  </back>
</rfc>
